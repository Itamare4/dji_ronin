/* log to today file and delete old files.
 Multiline string will automatically prepend date string and optional tag.

 var log = require('./logger.js').create('someDir/log.txt', 2); //keepOldFileDays: 2

 -------------------------statement------------------  ---------output---------------
 //Multiline log example:
 log('msg1\nMsg2');
 23:59:59.999 msg1
 23:59:59.999 Msg2

 log('[myTag]', 'msg1\nMsg2');
 23:59:59.999 [myTag] msg1
 23:59:59.999 [myTag] Msg2

 //Join line example:
 log('[myTag]', 'processing...', false); //false means No Auto NewLine
 log('[myTag]', 'done.');
 23:59:59.991 [myTag] processing...done.

 //Broken line example:
 log('[myTag]', 'processing...', false);
 log('[Other]', 'things');
 23:59:59.991 [myTag] processing...####
 23:59:59.991 [Other] things

 //other information
 log.getLogFilePath(1)
 someDir/log_20131230.txt

 When day changes or first output, log file will be created with append mode, and old files will be deleted.  
 The file name will be inserted date string i.e. "log_20131231.txt" when request file name is "log.txt"
 */
exports.create = function (filePathPattern, keepOldFileDays) {
  'use strict';
  var fs = require('fs'), Path = require('path');

  var fd = -1, isLineEnded = true, wantedNextLineTag, err_write;
  var commonHead = '', dateObj = new Date(0), day = -1, re_basenameSuffix = /^_\d{8}$/; //_YYYYMMDD
  var dir = Path.dirname(filePathPattern), ext = Path.extname(filePathPattern), base = Path.basename(filePathPattern, ext);

  log.getLogFilePath = function (howManyDaysAgo/*optional*/) {
    return dir + '/' + base + makeDateSuffix(new Date(Date.now() - (howManyDaysAgo || 0) * 86400000)) + ext;
  };

  return log;

  function log(/*[OPTIONAL]tag, msg, [OPTIONAL]autoNewLine*/) {
    var nowMs = Date.now();
    if (nowMs !== dateObj.valueOf()) {
      dateObj.setTime(nowMs);

      //make head '23:59:59.999 '
      commonHead = dpad2(dateObj.getHours()) + ':' + dpad2(dateObj.getMinutes()) + ':' + dpad2(dateObj.getSeconds()) + '.' + dpad3(dateObj.getMilliseconds()) + ' ';

      //close current and create new log file if date changed
      if (dateObj.getDate() !== day) {
        day = dateObj.getDate();
        if (fd !== -1) {
          try {
            fs.closeSync(fd);
          } catch (e) {
          }
          fd = -1;
          err_write = false;
        }
        try {
          fd = fs.openSync(dir + '/' + base + makeDateSuffix(dateObj) + ext, 'a');
        }
        catch (e) {
          process.stderr.write(commonHead + 'Failed to open/create file. ' + e + '\n');
        }
        deleteOldFiles();
      }
    }

    var tag = '', msg = '', autoNewLine = true;
    if (arguments.length >= 2) {
      tag = String(arguments[0]);
      msg = String(arguments[1]);
      if (arguments.length > 2 && arguments[2] === false) {
        autoNewLine = false;
      }
      if (tag.charCodeAt(tag.length - 1) !== 0x20/*space*/) {
        tag += ' ';
      }
    } else if (arguments.length >= 1) {
      msg = String(arguments[0]);
    }

    var head = commonHead + tag;

    //remove last new line char
    var origMsgIsEndedWithNewLine = (msg.charCodeAt(msg.length - 1) === 0xa);
    if (origMsgIsEndedWithNewLine) {
      var crCount = 0;
      while (msg.charCodeAt(msg.length - 2 - crCount) === 0xd)
        crCount++;
      msg = msg.slice(0, -1 - crCount);
    }

    //prepend head to each line. To disable this, just change to "var s = msg"
    var s = msg.replace(/\r*\n/g, '\n' + head).replace(/\0/g, '\\0');

    if (isLineEnded) {
      s = head + s;
    } else if (tag !== wantedNextLineTag) {
      s = ' ####\n' + head + s;
    }
    if (origMsgIsEndedWithNewLine || autoNewLine) {
      s += '\n';
      isLineEnded = true;
      wantedNextLineTag = undefined;
    } else {
      isLineEnded = false;
      wantedNextLineTag = tag;
    }

    //write to file if filePath is specified
    if (fd !== -1) {
      try {
        fs.writeSync(fd, s); //writeSync does not call sync
        fs.fsyncSync(fd);
      } catch (e) {
        !err_write && (err_write = true) && process.stderr.write(commonHead + 'Failed to append log to file. ' + e + '\n');
        try {
          process.stderr.write(s);
        } catch (e) {
        }
      }
    }

    return true;
  } //end of log()

  function deleteOldFiles() {
    var criticalDate = new Date(dateObj);
    criticalDate.setDate(dateObj.getDate() - 1 - (keepOldFileDays || 0));
    var criticalDateStr = makeDateSuffix(criticalDate);
    try {
      fs.readdirSync(dir).forEach(function (name) {
        if (Path.extname(name) === ext) {
          var _base = Path.basename(name, ext);
          if (_base.slice(0, base.length) === base) {
            var _suffix = _base.slice(base.length);
            if (_suffix <= criticalDateStr && re_basenameSuffix.test(_suffix)) {
              try {
                //do not delete the file modified just a moment ago
                if (_suffix !== criticalDateStr || fs.statSync(dir + '/' + name).mtime.valueOf() <= criticalDate.valueOf()) {
                  fs.unlinkSync(dir + '/' + name);
                }
              } catch (e) {
              }
            }
          }
        }
      });
    }
    catch (e) {
      if (e.code !== 'ENOENT') {
        process.stderr.write(commonHead + 'Failed to search or delete old log files. ' + e + '\n');
      }
    }
  } //end of deleteOldFiles()

  function makeDateSuffix(dt) { //_YYYYMMDD   //note: must match re_basenameSuffix
    return '_' + dt.getFullYear() + dpad2(dt.getMonth() + 1) + dpad2(dt.getDate());
  }

  function dpad2(d) {
    return (d < 10) ? '0' + d : d.toString();
  }

  function dpad3(d) {
    return (d < 10) ? '00' + d : (d < 100) ? '0' + d : d.toString();
  }
};
